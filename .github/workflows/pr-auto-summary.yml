name: PR Auto Summary

on:
  pull_request:
    types: [opened, reopened, synchronize]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  summarize:
    # Cost guard: skip private repos and fork-based PRs.
    if: ${{ !github.event.repository.private && github.event.pull_request.head.repo.full_name == github.repository }}
    runs-on: ubuntu-latest
    timeout-minutes: 3
    concurrency:
      group: pr-auto-summary-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    steps:
      - name: Upsert PR summary comment
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- pr-auto-summary -->';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = context.payload.pull_request.number;
            const pr = context.payload.pull_request;

            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number, per_page: 100 }
            );

            const commits = await github.paginate(
              github.rest.pulls.listCommits,
              { owner, repo, pull_number, per_page: 100 }
            );

            const totals = files.reduce(
              (acc, f) => {
                acc.files += 1;
                acc.additions += f.additions || 0;
                acc.deletions += f.deletions || 0;
                return acc;
              },
              { files: 0, additions: 0, deletions: 0 }
            );

            const areas = {
              frontend: { files: 0, additions: 0, deletions: 0 },
              backend: { files: 0, additions: 0, deletions: 0 },
              ai: { files: 0, additions: 0, deletions: 0 },
              monorepo: { files: 0, additions: 0, deletions: 0 },
            };

            const detectArea = (filename) => {
              if (filename.startsWith('apps/frontend/')) return 'frontend';
              if (filename.startsWith('apps/backend/')) return 'backend';
              if (filename.startsWith('apps/ai/')) return 'ai';
              return 'monorepo';
            };

            for (const f of files) {
              const area = detectArea(f.filename);
              areas[area].files += 1;
              areas[area].additions += f.additions || 0;
              areas[area].deletions += f.deletions || 0;
            }

            const topFiles = [...files]
              .sort((a, b) => (b.changes || 0) - (a.changes || 0))
              .slice(0, 10);

            const commitLines = commits
              .map((c) => c.commit?.message?.split('\n')[0]?.trim())
              .filter(Boolean)
              .slice(0, 10);

            const hasInfraChange = files.some((f) =>
              f.filename === 'docker-compose.yml' ||
              f.filename.startsWith('docker/') ||
              f.filename.includes('Dockerfile')
            );
            const hasEnvChange = files.some((f) =>
              f.filename.includes('.env') ||
              f.filename.includes('application-prod.yml') ||
              f.filename.includes('database.py')
            );
            const hasDbChange = files.some((f) =>
              f.filename.endsWith('.sql') ||
              f.filename.toLowerCase().includes('database')
            );

            const risks = [];
            if (totals.files >= 20) {
              risks.push('변경 파일 수가 많아(20+) 회귀 위험이 있습니다. 핵심 시나리오 스모크 테스트를 권장합니다.');
            }
            if (hasInfraChange) {
              risks.push('인프라/컨테이너 변경이 포함되어 로컬 및 CI 실행 경로 차이가 생길 수 있습니다.');
            }
            if (hasEnvChange) {
              risks.push('환경 변수/설정 파일이 변경되어 실행 환경별 설정 누락 가능성이 있습니다.');
            }
            if (hasDbChange) {
              risks.push('DB 관련 변경이 포함되어 초기화/스키마 적용 순서 확인이 필요합니다.');
            }

            const checklist = [
              '- [ ] PR 본문(`Summary`, `Issue`)이 최신 변경 내용과 일치하는지 확인',
            ];
            if (areas.frontend.files > 0) {
              checklist.push('- [ ] Frontend 주요 화면에서 API 호출/프록시(`/api`) 동작 확인');
            }
            if (areas.backend.files > 0) {
              checklist.push('- [ ] Backend 기동 후 핵심 API smoke test 수행');
            }
            if (areas.ai.files > 0) {
              checklist.push('- [ ] AI 모델 파일/추론 엔드포인트 기동 확인');
            }
            if (hasInfraChange) {
              checklist.push('- [ ] `make up`/`make down`/`make reset-db` 시나리오 점검');
            }
            if (hasDbChange) {
              checklist.push('- [ ] DB 초기화 SQL 재실행(idempotent) 검증');
            }

            const areaRows = Object.entries(areas)
              .map(([name, s]) => `| ${name} | ${s.files} | +${s.additions} / -${s.deletions} |`)
              .join('\n');

            const topFilesRows = topFiles.length > 0
              ? topFiles.map((f) => `- \`${f.filename}\` (+${f.additions}/-${f.deletions})`).join('\n')
              : '- 변경 파일 없음';

            const commitRows = commitLines.length > 0
              ? commitLines.map((m) => `- ${m}`).join('\n')
              : '- 커밋 메시지 없음';

            const riskRows = risks.length > 0
              ? risks.map((r) => `- ${r}`).join('\n')
              : '- 현재 자동 규칙 기준에서 높은 위험 신호는 감지되지 않았습니다.';

            const body = `${marker}
            ## Auto PR Summary
            - Base: \`${pr.base.ref}\` / Head: \`${pr.head.ref}\`
            - Commits: **${commits.length}**
            - Files changed: **${totals.files}** (+${totals.additions} / -${totals.deletions})

            ### Area Breakdown
            | Area | Files | LOC |
            |---|---:|---:|
            ${areaRows}

            ### Top Changed Files
            ${topFilesRows}

            ### Commit Highlights
            ${commitRows}

            ### Reviewer Checklist
            ${checklist.join('\n')}

            ### Risk Signals
            ${riskRows}

            _Updated automatically on ${new Date().toISOString()}_`;

            const comments = await github.paginate(
              github.rest.issues.listComments,
              { owner, repo, issue_number: pull_number, per_page: 100 }
            );

            const existing = comments.find(
              (c) =>
                c.user?.login === 'github-actions[bot]' &&
                typeof c.body === 'string' &&
                c.body.includes(marker)
            );

            try {
              if (existing) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existing.id,
                  body,
                });
                core.info(`Updated existing summary comment: ${existing.id}`);
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body,
                });
                core.info('Created new summary comment.');
              }
            } catch (error) {
              core.warning(`Failed to upsert PR summary comment: ${error.message}`);
            }
